#!/usr/bin/env python
#
#     COURSE:  COMP 4140
# INSTRUCTOR:  Michael Zapp
# ASSIGNMENT:  Research Paper, RC4 Cryptanalysis
# STUDENT(S):  Matt Deutscher, Josh Westlake
#
#      USAGE:  python rc4_roos_bias.py

import rc4
import os


class KeyCategory:
    WEAK, RANDOM = range(2)


# A version agnostic method to sum all values of a dictionary
def sum_all_values(d):
    total = 0
    for i in range(len(d)):
        total += d[i]
    return total


# Creates a dictionary containing counts of how far apart the 3rd byte of each key is from the first byte of ciphertext
# created using the key. If show_output is true will output verbose logs showing each comparison and result
def get_distribution(keys, show_output):

    dist = [0] * 256
    count = 0
    positives = 0
    answer = 'false'

    for key in keys:

        if show_output:
            print 'key:'
            print ''.join('{:02x} '.format(x) for x in key)

        # make a string from the key's bytestring (our rc4 implementation only accepts strings)
        key_string = "".join(map(chr, key))
        ciphertext, first_byte = rc4.crypt("This is my sample fixed message",
                                           key_string)

        # check if they value of the third key byte is 3 lower than the first output byte
        k2 = hex(key[2] + 3)
        if k2 == first_byte:
            answer = 'true'
            positives += 1

        if show_output:
            print 'first generated byte by RC4: ' + str(first_byte)[2:]
            print 'byte equal to K[2] + 3: ' + answer

        # update the distribution dictionary
        dist[int(first_byte, 0) - key[2]] += 1
        count += 1
        answer = 'false'

    prob = float(positives) / float(count)
    if show_output:
        print 'Total of {0} positives out of {1} keys, probability = {2}'.format(positives, count, prob)

    return dist


# Outputs a table showing the difference in distribution between weak and random keys.
def show_probabilities(weak_dist, rand_dist):
    weak_count = sum_all_values(weak_dist)
    rand_count = sum_all_values(rand_dist)

    print "From a sample of %i keys the distribution is..." % weak_count
    print ""
    print " Prob. that K[2] = B[0] - x    Weak Keys     Random Keys "
    print "=============================================================="

    for i in range(256):
        weak_dist_prob = (weak_dist[i] / (weak_count + 0.0)) * 100
        rand_dist_prob = (rand_dist[i] / (rand_count + 0.0)) * 100

        print "          x = %3i              %6.2f %%       %6.2f %%        " % (
            i, weak_dist_prob, rand_dist_prob)


# Generate a set of keys that are either random or weak (as defined by Roo's bias)
def generate_keys(key_type, count):
    keys = []

    # Adjust the range of k if you want to generate keys of varying lengths. We've left it fixed at 16 byte keys
    for k in range(16, 17):

        # Generate 256 different keys with every variation of Roo's bias
        for i in range(count):

            key = bytearray(k)

            # For weak keys set the first 2 bytes to <i, 256-i> (mod 256)
            if key_type == KeyCategory.WEAK:
                key[0] = i % 256
                key[1] = (256 - i) % 256
            # Random keys will randomize the first 2 bytes
            elif key_type == KeyCategory.RANDOM:
                key[0] = os.urandom(1)
                key[1] = os.urandom(1)

            # Fill the remaining bytes of the key with random bytes using a cryptographically suitable PRNG
            for j in range(2, k):
                key[j] = os.urandom(1)

            keys.append(key)

    return keys


def main():

    key_count = 10000

    print "Generating %i weak keys and encrypting... " % key_count
    weak_key_distribution = get_distribution(generate_keys(KeyCategory.WEAK, key_count), False)
    print "Generating %i random keys and encrypting... " % key_count
    rand_key_distribution = get_distribution(generate_keys(KeyCategory.RANDOM, key_count), False)

    print "Recording distribution of differences between K[2] & B[0]..."
    show_probabilities(weak_key_distribution, rand_key_distribution)


if __name__ == '__main__':
    main()
